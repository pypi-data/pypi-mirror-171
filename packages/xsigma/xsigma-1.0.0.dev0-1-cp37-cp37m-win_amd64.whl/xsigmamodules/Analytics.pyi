from typing import overload, Any, Callable, TypeVar, Union
from typing import Tuple, List, Sequence, MutableSequence

Callback = Union[Callable[..., None], None]
Buffer = TypeVar('Buffer')
Pointer = TypeVar('Pointer')
Template = TypeVar('Template')

import xsigmamodules.Core
import xsigmamodules.Market

class parameter_markovian_hjm_type(int):
    HULL_WHITE:'parameter_markovian_hjm_type'
    PICEWISE_CONSTANT:'parameter_markovian_hjm_type'

class bermudanStrikesLifeCycle(xsigmamodules.Market.lifeCycleData):
    @overload
    def excution_boundary_strikes(self, index:int) -> float: ...
    @overload
    def excution_boundary_strikes(self) -> (float, ...): ...

class calibrationBlackKarasinski(object):
    def calibrate_level(self, credit_parameters:parameterBlackKarasinski): ...

class calibrationCreditBlackKarasinskiSettings(xsigmamodules.Market.configData):
    def mean_reversion_spead(self) -> float: ...
    def read_from_binary(file_name:str) -> calibrationCreditBlackKarasinskiSettings: ...
    def read_from_json(file_name:str) -> calibrationCreditBlackKarasinskiSettings: ...
    def use_pde(self) -> bool: ...
    def write_to_binary(file_name:str, rhs:calibrationCreditBlackKarasinskiSettings) -> None: ...
    def write_to_json(file_name:str, rhs:calibrationCreditBlackKarasinskiSettings) -> None: ...

class calibrationIrHjm(object):
    def calibrate(self, volatility_surface:irVolatilitySurface, correlation:matrix_IdE, settings:calibrationIrHjmSettings, strikes:(float, ...)=..., initial_parameter:parameterMarkovianHjm=...) -> parameterMarkovianHjm: ...
    def swaptions(self) -> (calibrationIrHjmSwaption, ...): ...

class calibrationIrHjmSettings(xsigmamodules.Market.configData):
    def debug(self) -> bool: ...
    def read_from_binary(file_name:str) -> calibrationIrHjmSettings: ...
    def read_from_json(file_name:str) -> calibrationIrHjmSettings: ...
    def tolerance(self) -> float: ...
    def type(self) -> parameterMarkovianHjmType: ...
    def write_to_binary(file_name:str, rhs:calibrationIrHjmSettings) -> None: ...
    def write_to_json(file_name:str, rhs:calibrationIrHjmSettings) -> None: ...

class calibrationIrTargetsConfiguration(xsigmamodules.Market.configData):
    def cms_tenors(self) -> (tenor, ...): ...
    def coterminal(self) -> tenor: ...
    def expiries(self) -> (tenor, ...): ...
    def frequency(self) -> tenor: ...
    def include_caplets(self) -> bool: ...
    def include_cms(self) -> bool: ...
    def include_coterminal(self) -> bool: ...
    def read_from_binary(file_name:str) -> calibrationIrTargetsConfiguration: ...
    def read_from_json(file_name:str) -> calibrationIrTargetsConfiguration: ...
    def write_to_binary(file_name:str, rhs:calibrationIrTargetsConfiguration) -> None: ...
    def write_to_json(file_name:str, rhs:calibrationIrTargetsConfiguration) -> None: ...

class changeOfMeasure(object): ...

class correlationManager(xsigmamodules.Market.marketData):
    def id(self, i:int) -> diffusionId: ...
    def ids(self) -> (diffusionId, ...): ...
    def number_of_factors(self, id:diffusionId) -> int: ...
    def pair_correlation_matrix(self, ids1:(diffusionId, ...), ids2:(diffusionId, ...)) -> matrix_IdE: ...
    def read_from_binary(file_name:str) -> correlationManager: ...
    def read_from_json(file_name:str) -> correlationManager: ...
    def write_to_binary(file_name:str, rhs:correlationManager) -> None: ...
    def write_to_json(file_name:str, rhs:correlationManager) -> None: ...

class diffusion(object):
    def create_market_data(self, asset:diffusion, next:matrix_IdE, current:matrix_IdE, data:(marketData, ...)) -> marketData: ...
    def diffusion_discount_curve(data:marketData) -> discountCurve: ...
    def diffusion_equity_spot(data:marketData) -> equitySpot: ...
    def diffusion_fx_spot(data:marketData) -> fxSpot: ...
    def diffusion_survival_curve(data:marketData) -> survivalCurve: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...

class diffusionCredit(diffusion):
    def create_market_data(self, asset:diffusion, next:matrix_IdE, current:matrix_IdE, data:(marketData, ...)) -> marketData: ...
    def log_conditional_survival_probability(self, output:vector_IdE, states:matrix_IdE, from_:datetime, to:datetime) -> None: ...
    def survival_probability(self, output:vector_IdE, states:matrix_IdE, from_:datetime) -> None: ...

class diffusionCreditBlackKarasinski(diffusionCredit):
    def log_conditional_survival_probability(self, output:vector_IdE, states:matrix_IdE, from_:datetime, to:datetime) -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...
    def survival_probability(self, output:vector_IdE, states:matrix_IdE, from_:datetime) -> None: ...

class diffusionCreditExtendedCir(diffusionCredit):
    def log_conditional_survival_probability(self, output:vector_IdE, states:matrix_IdE, from_:datetime, to:datetime) -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...
    def survival_probability(self, output:vector_IdE, states:matrix_IdE, from_:datetime) -> None: ...

class diffusionId(xsigmamodules.Market.marketDataId):
    def hash(self) -> int: ...
    def to_string(self) -> str: ...

class diffusionCreditId(diffusionId):
    def hash(self) -> int: ...
    def id(self) -> defaultId: ...
    def read_from_binary(file_name:str) -> diffusionCreditId: ...
    def read_from_json(file_name:str) -> diffusionCreditId: ...
    def to_string(self) -> str: ...
    def write_to_binary(file_name:str, rhs:diffusionCreditId) -> None: ...
    def write_to_json(file_name:str, rhs:diffusionCreditId) -> None: ...

class diffusionCreditMarkovianHjm(diffusionCredit):
    def log_conditional_survival_probability(self, output:vector_IdE, states:matrix_IdE, from_:datetime, to:datetime) -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...
    def survival_probability(self, output:vector_IdE, states:matrix_IdE, from_:datetime) -> None: ...

class diffusionEquity(diffusion):
    def create_market_data(self, asset:diffusion, next:matrix_IdE, current:matrix_IdE, data:(marketData, ...)) -> marketData: ...
    def domestic_curve(self) -> discountCurve: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...

class diffusionEquityId(diffusionId):
    def diffusion_ir_id_domestic(self) -> diffusionIrId: ...
    def hash(self) -> int: ...
    def read_from_binary(file_name:str) -> diffusionEquityId: ...
    def read_from_json(file_name:str) -> diffusionEquityId: ...
    def to_string(self) -> str: ...
    def write_to_binary(file_name:str, rhs:diffusionEquityId) -> None: ...
    def write_to_json(file_name:str, rhs:diffusionEquityId) -> None: ...

class diffusionEquityLognormal(diffusionEquity):
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...

class diffusionFx(diffusion):
    def create_market_data(self, asset:diffusion, next:matrix_IdE, current:matrix_IdE, data:(marketData, ...)) -> marketData: ...
    def domestic_curve(self) -> discountCurve: ...
    def foreign_curve(self) -> discountCurve: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...

class diffusionFxId(diffusionId):
    def diffusion_ir_id_domestic(self) -> diffusionIrId: ...
    def diffusion_ir_id_foreign(self) -> diffusionIrId: ...
    def hash(self) -> int: ...
    def read_from_binary(file_name:str) -> diffusionFxId: ...
    def read_from_json(file_name:str) -> diffusionFxId: ...
    def to_string(self) -> str: ...
    def write_to_binary(file_name:str, rhs:diffusionFxId) -> None: ...
    def write_to_json(file_name:str, rhs:diffusionFxId) -> None: ...

class diffusionFxLognormal(diffusionFx):
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...

class diffusionIr(diffusion):
    def create_market_data(self, asset:diffusion, next:matrix_IdE, current:matrix_IdE, data:(marketData, ...)) -> marketData: ...
    def discounting(self, output:vector_IdE, states:matrix_IdE, from_:datetime) -> None: ...
    def log_df(self, output:vector_IdE, states:matrix_IdE, from_:datetime, to:datetime) -> None: ...
    def log_normalized_discounting(self, states:matrix_IdE) -> vector_IdE: ...

class diffusionIrBlackKarasinski(diffusionIr):
    def discounting(self, output:vector_IdE, states:matrix_IdE, from_:datetime) -> None: ...
    def log_df(self, output:vector_IdE, states:matrix_IdE, from_:datetime, to:datetime) -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...

class diffusionIrCheyette(diffusionIr):
    def discounting(self, output:vector_IdE, states:matrix_IdE, from_:datetime) -> None: ...
    def log_df(self, output:vector_IdE, states:matrix_IdE, from_:datetime, to:datetime) -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...

class diffusionIrExtendedCir(diffusionIr):
    def discounting(self, output:vector_IdE, states:matrix_IdE, from_:datetime) -> None: ...
    def log_df(self, output:vector_IdE, states:matrix_IdE, from_:datetime, to:datetime) -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...

class diffusionIrId(diffusionId):
    def hash(self) -> int: ...
    def id(self) -> discountId: ...
    def read_from_binary(file_name:str) -> diffusionIrId: ...
    def read_from_json(file_name:str) -> diffusionIrId: ...
    def to_string(self) -> str: ...
    def write_to_binary(file_name:str, rhs:diffusionIrId) -> None: ...
    def write_to_json(file_name:str, rhs:diffusionIrId) -> None: ...

class diffusionIrMarkovianHjm(diffusionIr):
    def discounting(self, output:vector_IdE, states:matrix_IdE, from_:datetime) -> None: ...
    def log_df(self, output:vector_IdE, states:matrix_IdE, from_:datetime, to:datetime) -> None: ...
    def number_of_factors(self) -> int: ...
    def number_of_states(self) -> int: ...
    def states_initalize(self, states:matrix_IdE) -> None: ...

class instrument(object):
    def make_life_cycle_data(self) -> lifeCycleData: ...
    def size(self) -> int: ...
    def value(self, expiry:datetime, mkt_data:(marketData, ...), output:tensor_IdE) -> None: ...

class instrumentBermudanSwaption(instrument):
    def make_life_cycle_data(self) -> lifeCycleData: ...
    def size(self) -> int: ...
    def swaptoins(self) -> (instrumentIrSwaption, ...): ...
    def value(self, expiry:datetime, mkt_data:(marketData, ...), output:tensor_IdE) -> None: ...

class instrumentCreditBond(instrument):
    def convention(self) -> dayCountConvention: ...
    def maturity(self) -> datetime: ...
    def size(self) -> int: ...
    def value(self, expiry:datetime, mkt_data:(marketData, ...), output:tensor_IdE) -> None: ...

class instrumentIrBond(instrument):
    def convention(self) -> dayCountConvention: ...
    def maturity(self) -> datetime: ...
    def size(self) -> int: ...
    def value(self, expiry:datetime, mkt_data:(marketData, ...), output:tensor_IdE) -> None: ...

class instrumentIrSwaption(instrument):
    def is_call(self) -> bool: ...
    def size(self) -> int: ...
    def strikes(self) -> (float, ...): ...
    def swap(self) -> interestRateSwap: ...
    def value(self, expiry:datetime, mkt_data:(marketData, ...), output:tensor_IdE) -> None: ...

class interestRateSwap(object):
    def all_dates(self) -> (datetime, ...): ...
    def annuity(self) -> float: ...
    def expiry(self) -> datetime: ...
    @overload
    def implied_volatility(self, value:float, strike:float, is_call:float=1) -> float: ...
    @overload
    def implied_volatility(self, volatility_surface:irVolatilitySurface, strike:float) -> float: ...
    def is_caplet(self) -> bool: ...
    def maturity(self) -> datetime: ...
    def simulated_value(self, mm:vector_IdE, curve:discountCurve, strikes:(float, ...), is_call:bool, moment_matching:bool, debug:bool) -> (float, ...): ...
    @overload
    def swap_rate(self, dfs:(float, ...)) -> float: ...
    @overload
    def swap_rate(self) -> float: ...
    def value(self, strike:float, dfs:(float, ...)) -> float: ...

class lognormalModelWithMhjmIr(object):
    def calibrate(self, calibration_dates:(datetime, ...), market_variance:(float, ...), day_convention:dayCountConvention) -> parameterLognormal: ...

class lognormalEquityWithMhjmIr(lognormalModelWithMhjmIr): ...

class lognormalFxWithMhjmIr(lognormalModelWithMhjmIr): ...

class measure(xsigmamodules.Market.configData):
    @overload
    def __init__(self, id:discountId) -> None: ...
    @overload
    def __init__(self, __a:measure) -> None: ...
    def id(self) -> discountId: ...
    def read_from_binary(file_name:str) -> measure: ...
    def read_from_json(file_name:str) -> measure: ...
    def write_to_binary(file_name:str, rhs:measure) -> None: ...
    def write_to_json(file_name:str, rhs:measure) -> None: ...

class measureId(xsigmamodules.Market.configDataId):
    def hash(self) -> int: ...
    def read_from_binary(file_name:str) -> measureId: ...
    def read_from_json(file_name:str) -> measureId: ...
    def to_string(self) -> str: ...
    def write_to_binary(file_name:str, rhs:measureId) -> None: ...
    def write_to_json(file_name:str, rhs:measureId) -> None: ...

class parameterBlackKarasinski(xsigmamodules.Core.aadStateParametersManager):
    def parameters(self) -> parameterMarkovianHjm: ...
    def read_from_binary(file_name:str) -> parameterBlackKarasinski: ...
    def read_from_json(file_name:str) -> parameterBlackKarasinski: ...
    def write_to_binary(file_name:str, rhs:parameterBlackKarasinski) -> None: ...
    def write_to_json(file_name:str, rhs:parameterBlackKarasinski) -> None: ...

class parameterCheyette(xsigmamodules.Core.aadStateParametersManager):
    def long_term_skew_level(self) -> float: ...
    def parameters(self) -> parameterMarkovianHjm: ...
    def read_from_binary(file_name:str) -> parameterCheyette: ...
    def read_from_json(file_name:str) -> parameterCheyette: ...
    def skew_parameter(self) -> matrix_IdE: ...
    def skew_parameter_dates(self) -> (datetime, ...): ...
    def write_to_binary(file_name:str, rhs:parameterCheyette) -> None: ...
    def write_to_json(file_name:str, rhs:parameterCheyette) -> None: ...

class parameterExtendedCir(xsigmamodules.Core.aadStateParametersManager):
    def correlation(self) -> matrix_IdE: ...
    def day_convention(self) -> dayCountConvention: ...
    def mean_reversion_speed_dates(self) -> (datetime, ...): ...
    def mean_reversion_speeds(self) -> matrix_IdE: ...
    def read_from_binary(file_name:str) -> parameterExtendedCir: ...
    def read_from_json(file_name:str) -> parameterExtendedCir: ...
    def shifts(self) -> matrix_IdE: ...
    def shifts_dates(self) -> (datetime, ...): ...
    def volatilities(self) -> matrix_IdE: ...
    def volatilities_dates(self) -> (datetime, ...): ...
    def write_to_binary(file_name:str, rhs:parameterExtendedCir) -> None: ...
    def write_to_json(file_name:str, rhs:parameterExtendedCir) -> None: ...

class parameterLognormal(xsigmamodules.Core.aadStateParametersManager):
    def correlation(self) -> matrix_IdE: ...
    def day_convention(self) -> dayCountConvention: ...
    def number_of_factors(self) -> int: ...
    def read_from_binary(file_name:str) -> parameterLognormal: ...
    def read_from_json(file_name:str) -> parameterLognormal: ...
    def volatilities(self) -> matrix_IdE: ...
    def volatilities_dates(self) -> (datetime, ...): ...
    def write_to_binary(file_name:str, rhs:parameterLognormal) -> None: ...
    def write_to_json(file_name:str, rhs:parameterLognormal) -> None: ...

class parameterMarkovianHjm(xsigmamodules.Core.aadStateParametersManager):
    def correlation(self) -> matrix_IdE: ...
    def day_convention(self) -> dayCountConvention: ...
    def decays(self) -> matrix_IdE: ...
    def decays_dates(self) -> (datetime, ...): ...
    def model_type(self) -> parameterMarkovianHjmType: ...
    def number_of_factors(self) -> int: ...
    def read_from_binary(file_name:str) -> parameterMarkovianHjm: ...
    def read_from_json(file_name:str) -> parameterMarkovianHjm: ...
    def volatilities(self) -> matrix_IdE: ...
    def volatilities_dates(self) -> (datetime, ...): ...
    def write_to_binary(file_name:str, rhs:parameterMarkovianHjm) -> None: ...
    def write_to_json(file_name:str, rhs:parameterMarkovianHjm) -> None: ...

class randomConfig(xsigmamodules.Market.configData):
    def main_generator_type(self) -> randomType: ...
    def read_from_binary(file_name:str) -> randomConfig: ...
    def read_from_json(file_name:str) -> randomConfig: ...
    def settings(self) -> randomSettings: ...
    def write_to_binary(file_name:str, rhs:randomConfig) -> None: ...
    def write_to_json(file_name:str, rhs:randomConfig) -> None: ...

class simulationManager(object):
    def data(self, i:int) -> marketData: ...
    def propagate(self, time_index:int) -> None: ...
    def states_initalize(self) -> None: ...


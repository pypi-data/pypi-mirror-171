# coding: utf-8

"""
    VIER Cognitive Voice Recording API

    With the Recording API, client applications can manage recordings that have previously been created using the Call or Assist APIs.  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: support@vier.ai
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from cvg_sdk import schemas  # noqa: F401


class Transcript(
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    This object represents a recording transcript. The transcript object is versioned to allow us to improve the
format in the future.

Transcripts are a condensed representation of the dialog as it would have been observed by a third person
listening in and they are restricted to the sections of the dialog that have been recorded.

If you want to process the data programmatically, the Dialog API is most likely more suitable.
The data it returns covers the entire dialog and is more structured to retain relevant information about
advanced features like prompts.
    """


    class MetaOapg:
        
        @staticmethod
        def discriminator():
            return {
                'version': {
                    '1': TranscriptV1,
                    'TranscriptV1': TranscriptV1,
                }
            }
        
        class properties:
            
            
            class version(
                schemas.EnumBase,
                schemas.StrSchema
            ):
            
            
                class MetaOapg:
                    enum_value_to_name = {
                        "1": "POSITIVE_1",
                    }
                
                @schemas.classproperty
                def POSITIVE_1(cls):
                    return cls("1")
            __annotations__ = {
                "version": version,
            }
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["version"]) -> MetaOapg.properties.version: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["version", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["version"]) -> typing.Union[MetaOapg.properties.version, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["version", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        version: typing.Union[MetaOapg.properties.version, str, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'Transcript':
        return super().__new__(
            cls,
            *args,
            version=version,
            _configuration=_configuration,
            **kwargs,
        )

from cvg_sdk.model.transcript_v1 import TranscriptV1

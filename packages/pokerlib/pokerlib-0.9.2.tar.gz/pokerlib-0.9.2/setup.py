# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pokerlib', 'pokerlib.statistics']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'pokerlib',
    'version': '0.9.2',
    'description': 'Python poker library',
    'long_description': "# pokerlib\n[![PyPI version](https://badge.fury.io/py/pokerlib.svg)](https://pypi.org/project/pokerlib)\n\n## General\nA lightweight Python poker library that focuses on simplifying a poker game implementation\nwhen its io is supplied. It includes modules that help with hand parsing and poker game continuation.\n\nOne application of this library was made by the PokerMessenger app,\nwhich supplies library with io in the form of messenger group threads.\nThe app's repo is at https://github.com/kuco23/pokermessenger.\n\n## Usage\nLibrary consists of a module for parsing cards, which can be used seperately, and modules \nthat aid in running a poker game.\n\n### HandParser\nThis module helps with parsing hands. A hand usually consists of 2 dealt cards plus 5 on the board, \nand `HandParser` is optimized to work with up to 7 cards (otherwise flushes and straights \nrequire some small additional work). A card is defined as a pair of two enums. \nAll of the enums used are of `IntEnum` type, so you can also freely interchange them for integers. \nBelow is an example of how to construct two different hands and then compare them.\n\n```python\nhand1 = HandParser([\n    (Rank.KING, Suit.SPADE),\n    (Rank.ACE, Suit.SPADE)\n])\n\nhand2 = HandParser([\n    (Rank.NINE, Suit.SPADE),\n    (Rank.TWO, Suit.CLUB)\n])\n\nboard = [\n    (Rank.EIGHT, Suit.SPADE),\n    (Rank.TEN, Suit.SPADE),\n    (Rank.JACK, Suit.SPADE),\n    (Rank.QUEEN, Suit.SPADE),\n    (Rank.TWO, Suit.HEART)\n]\n\n# This is the same as adding the cards \n# in the HandParser constructor\nhand1 += board # add the board to hand1\nhand2 += board # add the board to hand2\n\nhand1.parse()\nhand2.parse()\n\nprint(hand1.handenum) # Hand.STRAIGHTFLUSH\nprint(hand2.handenum) # Hand.STRAIGHTFLUSH\nprint(hand1 > hand2) # True\n```\n\nIt is also possible to fetch hand's kickers.\n\n```python\nhand = HandParser([\n    (Rank.TWO, Suit.DIAMOND),\n    (Rank.ACE, Suit.CLUB),\n    (Rank.TWO, Suit.SPADE),\n    (Rank.THREE, Suit.DIAMOND),\n    (Rank.TEN, Suit.HEART),\n    (Rank.SIX, Suit.HEART),\n    (Rank.KING, Suit.CLUB)\n])\n\nhand.parse()\nprint(list(hand.kickercards))\n# [\n#   (<Rank.ACE: 12>, <Suit.CLUB: 1>),\n#   (<Rank.KING: 11>, <Suit.CLUB: 1>),\n#   (<Rank.TEN: 8>, <Suit.HEART: 3>)\n# ]\n```\n\nNote that `kickers` attribute saves the indices of `hand.cards` that form `kickercards`.\n\nAn important functionality of poker libraries is that they can estimate the probability\nof a hand winning in a certain context (as implemented [here](https://github.com/cookpete/poker-odds)).\nThis is done by repeatedly random-sampling hands and then averaging the wins.\nMathematically, this process converges to the probability by the law of large numbers.\n\n```python\nfrom random import sample\nfrom itertools import product\nfrom pokerlib import HandParser\nfrom pokerlib.enums import Rank, Suit\n\ndef getWinningProbabilities(players_cards, board=[], n=1000):\n    cards = list(product(Rank, Suit))\n    for player_cards in players_cards:\n        for card in player_cards:\n            cards.remove(card)\n\n    wins = [0] * len(players_cards)\n    for i in range(n):\n        board_ = sample(cards, 5-len(board))\n        hands = [\n            HandParser(player_cards + board + board_)\n            for player_cards in players_cards\n        ]\n        for hand in hands: hand.parse()\n        winner = max(hands)\n        for i, hand in enumerate(hands):\n            if hand == winner: wins[i] += 1\n\n    return [win / n for win in wins]\n    \nw1, w2 = getWinningProbabilities([\n    [(Rank.ACE, Suit.HEART), (Rank.KING, Suit.HEART)],\n    [(Rank.KING, Suit.SPADE), (Rank.KING, Suit.DIAMOND)]\n])\n```\n\n### Poker Game\nA poker table can be established by providing its configuration.\nThe main idea of a poker table is that it responds with output to given input.\nThat output can be further customized by overriding two functions that produce it.\n\n```python\nfrom pokerlib import Player, PlayerGroup, Table\n\n# just print the output\nclass MyTable(Table):\n    def publicOut(self, out_id, **kwargs):\n        print(out_id, kwargs)\n    def privateOut(self, player_id, out_id, **kwargs):\n        print(out_id, kwargs)\n\ntable = MyTable(\n    table_id = 0\n    seats = 2\n    players = PlayerGroup([])\n    buyin = 100\n    small_blind = 5\n    big_blind = 10\n)\n```\n\nWe could provide players above inside the list, but let's add them seperately,\nas this is often the case in practice.\n\n```python\nplayer1 = Player(\n    table_id = table.id,\n    _id = 1,\n    name = 'alice',\n    money = table.buyin\n)\nplayer2 = Player(\n    table_id = table.id,\n    _id = 2,\n    name = 'bob',\n    money = table.buyin\n)\ntable += [player1, player2]\n```\n\nIn the raw version, communication with the `table` object is established through specified enums\n(this can be changed by overriding table's `publicIn` method).\n\n```python\nfrom pokerlib.enums import RoundPublicInId, TablePublicInId\n\ntable.publicIn(player1.id, TablePublicInId.STARTROUND)\ntable.publicIn(player1.id, RoundPublicInId.CALL)\ntable.publicIn(player2.id, RoundPublicInId.CHECK)\ntable.publicIn(player1.id, RoundPublicInId.CHECK)\ntable.publicIn(player2.id, RoundPublicInId.RAISE, raise_by=50)\ntable.publicIn(player1.id, RoundPublicInId.CALL)\ntable.publicIn(player1.id, RoundPublicInId.CHECK)\ntable.publicIn(player2.id, RoundPublicInId.CHECK)\ntable.publicIn(player1.id, RoundPublicInId.ALLIN)\ntable.publicIn(player2.id, RoundPublicInId.CALL)\n```\n\nWrong inputs are mostly ignored, but can produce a response, \nwhen they seem to require it. As noted before, when providing input,\nthe `table` object responds with output ids (e.g. `PLAYERACTIONREQUIRED`)\nalong with additional data that depends on the output id.\nFor all possible outputs, check `RoundPublicInId` and `TablePublicInId` enums.\n\nA new round has to be initiated by one of the players every time the previous one ends (or at the beginning). \nA simple command line game, where you respond by enum names, can be implemented as\n\n```python\n# define a table with fixed players, as it was done before\nwhile table:\n    while table and not table.round:\n        table.publicIn(player1.id, TablePublicInId.STARTROUND)\n    p = table.round.current_player\n    i = input(f'Player {p.name}: ')\n    cmd = RoundPublicInId.__members__[i]\n    table.publicIn(p.id, cmd)\n```\n\n## Tests\nBasic tests for this library are included.\nFor instance `round_test.py` can be started from os terminal, by typing `python round_test.py <player_num> <game_type>`, after which a simulation is run with not-that-informative data getting printed in stdout.\n\n## License\nGNU General Public License v3.0\n",
    'author': 'kuco23',
    'author_email': 'nseverkar@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/kuco23/pokerlib/',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)

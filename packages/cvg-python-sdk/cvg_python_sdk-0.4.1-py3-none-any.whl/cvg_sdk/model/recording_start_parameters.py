# coding: utf-8

"""
    VIER Cognitive Voice Call API

    With the VIER Cognitive Voice Call API you can easily do things like building your voicebots, which can be reached via phone calls. You can receive speech input of the customer as transcripted text in many languages. Let different voices say your text in this call. After the voicebot dialog you may drop the call (call fully completed by bot) or transfer the call e.g. to the relevant service hotline (human agent required to satisfy customer).  On some events, such as receiving an incoming phone call or transcription of a customer's utterance, VIER makes an HTTP request to a URL to be provided by you. This is called a webhook. To handle a webhook, you need to build a small web application that can accept the HTTP requests. The required webhooks are listed as bot endpoints.  The operations defined in this specification can be used by your bot to trigger certain voice and/or telephony related actions on the currently active call.  Most of the available operations are subject to queuing, meaning that the commands, even when triggered simultaneously, will not be executed simultaneously. Instead, these operations will be executed after each other. This is being done to simplify bot development as otherwise the bot would need to hit exact timings for the operations it triggers to not produce overlapping audio in the phone and still be quick enough to feel responsive to the conversation partner.  The queuing mechanism allows the bot to simply trigger several operations after each other and CVG makes sure to to execute them without overlap after each other. Some operations also support a `bargeIn` flag, which makes the operation interruptible by the conversation partner.  All operations that are not subject to queuing will document this fact in their respective description.  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: support@vier.ai
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from cvg_sdk import schemas  # noqa: F401


class RecordingStartParameters(
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """


    class MetaOapg:
        required = {
            "dialogId",
        }
        
        class properties:
            dialogId = schemas.StrSchema
            maxDuration = schemas.IntSchema
        
            @staticmethod
            def recordingId() -> typing.Type['RecordingId']:
                return RecordingId
            
            
            class speakers(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    unique_items = True
                    min_items = 1
                    
                    @staticmethod
                    def items() -> typing.Type['Speaker']:
                        return Speaker
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple['Speaker'], typing.List['Speaker']],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'speakers':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> 'Speaker':
                    return super().__getitem__(i)
            __annotations__ = {
                "dialogId": dialogId,
                "maxDuration": maxDuration,
                "recordingId": recordingId,
                "speakers": speakers,
            }
    
    dialogId: MetaOapg.properties.dialogId
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dialogId"]) -> MetaOapg.properties.dialogId: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["maxDuration"]) -> MetaOapg.properties.maxDuration: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["recordingId"]) -> 'RecordingId': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["speakers"]) -> MetaOapg.properties.speakers: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["dialogId", "maxDuration", "recordingId", "speakers", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dialogId"]) -> MetaOapg.properties.dialogId: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["maxDuration"]) -> typing.Union[MetaOapg.properties.maxDuration, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["recordingId"]) -> typing.Union['RecordingId', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["speakers"]) -> typing.Union[MetaOapg.properties.speakers, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["dialogId", "maxDuration", "recordingId", "speakers", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        dialogId: typing.Union[MetaOapg.properties.dialogId, str, ],
        maxDuration: typing.Union[MetaOapg.properties.maxDuration, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        recordingId: typing.Union['RecordingId', schemas.Unset] = schemas.unset,
        speakers: typing.Union[MetaOapg.properties.speakers, list, tuple, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'RecordingStartParameters':
        return super().__new__(
            cls,
            *args,
            dialogId=dialogId,
            maxDuration=maxDuration,
            recordingId=recordingId,
            speakers=speakers,
            _configuration=_configuration,
            **kwargs,
        )

from cvg_sdk.model.recording_id import RecordingId
from cvg_sdk.model.speaker import Speaker
